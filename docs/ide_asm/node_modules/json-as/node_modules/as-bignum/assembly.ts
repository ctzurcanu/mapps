// @ts-nocheck
// export * from "./i128"; -
// export * from "./u128";
// export * from "./u256";
// export * from "./safe";

// import { u128 } from './u128';
// import { i256 } from './i256';
// import { u256 } from './u256';

// import {
//   __clz128,
//   __ctz128,
//   __floatuntidf,

//   __udivmod128,
//   __divmod_quot_hi,
//   __divmod_rem_lo,
//   __divmod_rem_hi,
// } from '../globals';
// import { atou128 } from '../utils';


// @ts-ignore: decorator
@lazy const MaxBaseForExponent128 = memory.data<u64>([
    u64.MAX_VALUE,       // 0
    u64.MAX_VALUE,       // 1
    u64.MAX_VALUE,       // 2
    0x000006597FA94F5B,  // 3
    0x00000000FFFFFFFF,  // 4
    0x0000000003080C00,  // 5
    0x0000000000285145,  // 6
    0x000000000004E045,  // 7
    0x000000000000FFFF,  // 8
    0x0000000000004AA8,  // 9
    0x0000000000001BDB,  // 10
    0x0000000000000C6F,  // 11
    0x0000000000000659,  // 12
    0x0000000000000398,  // 13
    0x0000000000000235,  // 14
    0x0000000000000172,  // 15
    0x00000000000000FF,  // 16
    0x00000000000000B8,  // 17
    0x000000000000008A,  // 18
    0x000000000000006A,  // 19
    0x0000000000000054,  // 20
    0x0000000000000044,  // 21
    0x0000000000000038,  // 22
    0x000000000000002F,  // 23
    0x0000000000000028,  // 24
    0x0000000000000022,  // 25
    0x000000000000001E,  // 26
    0x000000000000001A,  // 27
    0x0000000000000017,  // 28
    0x0000000000000015,  // 29
    0x0000000000000013,  // 30
    0x0000000000000011,  // 31
    0x000000000000000F,  // 32
    0x000000000000000E,  // 33
    0x000000000000000D,  // 34
    0x000000000000000C,  // 35
    0x000000000000000B,  // 36
    0x000000000000000B,  // 37
    0x000000000000000A,  // 38
  ]);

  // Use LUT wrapped by function for lazy compilation
  // @ts-ignore: decorator
  @lazy const RadixCharsTable = memory.data<u8>([
     0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 36, 36, 36, 36, 36, 36,
    36, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
    25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 36, 36, 36, 36,
    36, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
    25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35
  ]);

  // @ts-ignore: decorator
  @inline export function isPowerOverflow128(base: u128, exponent: i32): bool {
    // never overflow
    if (exponent <= 1 || base <= u128.One) {
      return false;
    }
    // always overflow
    if (base.hi != 0 || exponent >= 128) {
      return true;
    }
    var low = base.lo;
    if (low <= 10) {
      switch (<i32>low) {
        case 2:  return exponent > 127;
        case 3:  return exponent > 80;
        case 4:  return exponent > 63;
        case 5:  return exponent > 55;
        case 6:  return exponent > 49;
        case 7:  return exponent > 45;
        case 8:  return exponent > 42;
        case 9:  return exponent > 40;
        case 10: return exponent > 38;
      }
    }
    if (exponent >= 38) return true;
    return low > load<u64>(MaxBaseForExponent128 + (exponent << 3));
  }

  // helper function for utoa
  function processU64(digits: Uint8Array, value: u64): void {
    var length = digits.length - 1;
    for (let i = 63; i != -1; --i) {
      for (let j = 0; j <= length; ++j) {
        unchecked(digits[j] += (u8(digits[j] >= 5) * 3));
      }
      for (let j = length; j != -1; --j) {
        let d = unchecked(digits[j]) << 1;
        if (j < length) unchecked(digits[j + 1] |= u8(d > 15));
        unchecked(digits[j] = d & 15);
      }
      unchecked(digits[0] += u8((value & (1 << i)) != 0));
    }
  }

  export function u128toDecimalString(value: u128): string {
    var length = 40;
    var digits = new Uint8Array(length);
    var result = "", start = false;

    processU64(digits, value.hi);
    processU64(digits, value.lo);

    for (let i = length - 1; i != -1; --i) {
      let d = unchecked(digits[i]);
      if (!start && d != 0) start = true;
      if (start) {
        assert(<u32>d <= 9);
        result += String.fromCharCode(0x30 + d);
      }
    }
    return result;
  }

  export function u256toDecimalString(value: u256): string {
    var length = 78;
    var digits = new Uint8Array(length);
    var result = "", start = false;

    processU64(digits, value.hi2);
    processU64(digits, value.hi1);
    processU64(digits, value.lo2);
    processU64(digits, value.lo1);

    for (let i = length - 1; i != -1; --i) {
      let d = unchecked(digits[i]);
      if (!start && d != 0) start = true;
      if (start) {
        assert(<u32>d <= 9);
        result += String.fromCharCode(0x30 + d);
      }
    }
    return result;
  }

  export function atou128(str: string, radix: i32 = 10): u128 {
    if (radix < 2 || radix > 36) {
      throw new Error("Invalid radix");
    }
    var len = str.length;
    if (!len) return u128.Zero;

    var first = str.charCodeAt(0);
    if (len == 1 && first == CharCode._0) {
      return u128.Zero;
    }
    var isNeg = first == CharCode.MINUS;
    // @ts-ignore
    var index = i32(isNeg | (first == CharCode.PLUS));

    if (str.charCodeAt(index) == CharCode._0) {
      let second = str.charCodeAt(++index);
      if ((second | 32) == CharCode.x) {
        radix = 16; ++index;
      } else if ((second | 32) == CharCode.o) {
        radix = 8; ++index;
      } else if ((second | 32) == CharCode.b) {
        radix = 2; ++index;
      } else if (second == CharCode._0) {
        // skip leading zeros
        while (index < len && str.charCodeAt(index) == CharCode._0) ++index;
      }
    }
    var result = u128.Zero;
    var table  = RadixCharsTable;

    if (index >= len) return result;

    if (ASC_SHRINK_LEVEL >= 1) {
      let radix128 = u128.fromU64(radix);
      do {
        let n: u32 = str.charCodeAt(index) - CharCode._0;
        if (n > <u32>(CharCode.z - CharCode._0)) break;

        let num = load<u8>(table + n);
        if (num >= <u8>radix) break;

        // @ts-ignore
        result *= radix128;
        // @ts-ignore
        result += u128.fromU64(num);
      } while (++index < len);
    } else {
      switch (radix) {
        case 2: {
          do {
            let num: u32 = str.charCodeAt(index) - CharCode._0;
            if (num >= 2) break;
            // @ts-ignore
            result <<= 1;
            // @ts-ignore
            result |= u128.fromU64(num);
          } while (++index < len);
          break;
        }
        case 10: {
          do {
            let num: u32 = str.charCodeAt(index) - CharCode._0;
            if (num >= 10) break;
            // @ts-ignore
            result  = (result << 3) + (result << 1);
            // @ts-ignore
            result += u128.fromU64(num);
          } while (++index < len);
          break;
        }
        case 16: {
          do {
            let n: u32 = str.charCodeAt(index) - CharCode._0;
            if (n > <u32>(CharCode.z - CharCode._0)) break;

            let num = load<u8>(table + n);
            if (num >= 16) break;

            // @ts-ignore
            result <<= 4;
            // @ts-ignore
            result |= u128.fromU64(num);
          } while (++index < len);
          break;
        }
        default: {
          let radix128 = u128.fromU64(radix);
          do {
            let n: u32 = str.charCodeAt(index) - CharCode._0;
            if (n > <u32>(CharCode.z - CharCode._0)) break;

            let num = load<u8>(table + n);
            if (num >= <u8>radix) break;

            // @ts-ignore
            result *= radix128;
            // @ts-ignore
            result += u128.fromU64(num);
          } while (++index < len);
          break;
        }
      }
    }
    // @ts-ignore
    return isNeg ? -result : result;
  }


// used for returning quotient and reminder from __divmod128
@lazy export var __divmod_quot_hi: u64 = 0;
@lazy export var __divmod_rem_lo:  u64 = 0;
@lazy export var __divmod_rem_hi:  u64 = 0;

// used for returning low and high part of __mulq64, __multi3 etc
@lazy export var __res128_hi: u64 = 0;

/**
 * Convert 128-bit unsigned integer to 64-bit float
 * @param  lo lower  64-bit part of unsigned 128-bit integer
 * @param  hi higher 64-bit part of unsigned 128-bit integer
 * @return    64-bit float result
 */
// @ts-ignore: decorator
@global
export function __floatuntidf(lo: u64, hi: u64): f64 {
  // __floatuntidf ported from LLVM sources
  if (!(lo | hi)) return 0.0;

  var v  = new u128(lo, hi);
  var sd = 128 - __clz128(lo, hi);
  var e  = sd - 1;

  if (sd > 53) {
    if (sd != 55) {
      if (sd == 54) {
        v = u128.shl(v, 1);
      } else {
        v = u128.or(
          u128.shr(v, sd - 55),
          u128.fromBool(u128.and(v, u128.shr(u128.Max, 128 + 55 - sd)).toBool())
        );
      }
    }

    v.lo |= (v.lo & 4) >> 2;
    v.preInc();

    v = u128.shr(v, 2);

    if (v.lo & (1 << 53)) {
      v = u128.shr(v, 1);
      ++e;
    }

  } else {
    v = u128.shl(v, 53 - sd);
  }

  var w: u64 = u128.shr(v, 32).lo & 0x000FFFFF;
  var u: u64 = <u64>(((e + 1023) << 20) | w) << 32;
  return reinterpret<f64>(u | (v.lo & 0xFFFFFFFF));
}

// @ts-ignore: decorator
@global
export function __umulh64(a: u64, b: u64): u64 {
  var u = a & 0xFFFFFFFF; a >>= 32;
  var v = b & 0xFFFFFFFF; b >>= 32;

  var uv = u * v;
  var uv = a * v + (uv >> 32);
  var w0 = u * b + (uv & 0xFFFFFFFF);
  return a * b + (uv >> 32) + (w0 >> 32);
}

// @ts-ignore: decorator
@global
export function __umulq64(a: u64, b: u64): u64 {
  var u = a & 0xFFFFFFFF; a >>= 32;
  var v = b & 0xFFFFFFFF; b >>= 32;

  var uv = u * v;
  var w0 = uv & 0xFFFFFFFF;
      uv = a * v + (uv >> 32);
  var w1 = uv >> 32;
      uv = u * b + (uv & 0xFFFFFFFF);

  __res128_hi = a * b + w1 + (uv >> 32);
  return (uv << 32) | w0;
}

// @ts-ignore: decorator
@global
export function __multi3(al: u64, ah: u64, bl: u64, bh: u64): u64 {
  var u = al, v = bl;
  var w: u64, k: u64;

  var u1 = u & 0xFFFFFFFF; u >>= 32;
  var v1 = v & 0xFFFFFFFF; v >>= 32;
  var t  = u1 * v1;
  var w1 = t & 0xFFFFFFFF;

  t = u * v1 + (t >> 32);
  k = t & 0xFFFFFFFF;
  w = t >> 32;
  t = u1 * v + k;

  var lo  = (t << 32) | w1;
  var hi  = u  * v + w;
      hi += ah * bl;
      hi += al * bh;
      hi += t >> 32;

  __res128_hi = hi;
  return lo;
}

// @ts-ignore: decorator
@global
export function __floatuntfdi(value: f64): u64 {
  var u = reinterpret<u64>(value);

  // if (value < -1.7014118346046e38) { // -(2^127-1)
  if (value < reinterpret<f64>(0xC7F0000000000000)) { // -(2^128-1)
    // __float_u128_hi = <u64>-1; // for i128
    __res128_hi = 0;
    // overflow negative
    return 0;
    // } else if (value < -9.2233720368547e18) { // -2^63-1 // for i128
  } else if (value < reinterpret<f64>(0xC3F0000000000000)) { // // -(2^64-1)
    let lo: u64, hi: u64, m: u64;

    m = (u & 0x000FFFFFFFFFFFFF) | (1 << 52);
    u = (u & 0x7FFFFFFFFFFFFFFF) >> 52;

    u -= 1075;
    if (u > 64) {
      lo = 0;
      hi = m << (u - 64);
    } else {
      lo = m << u;
      hi = m >> (64 - u);
    }
    __res128_hi = ~hi;
    return ~lo;
    // } else if (value < 9.2233720368547e18) { // 2^63-1 // for i128
  } else if (value < reinterpret<f64>(0x43F0000000000000)) { // 2^64-1
    // __float_u128_hi = (value < 0) ? -1 : 0; // for int
    __res128_hi = 0;
    // fit in a u64
    return <u64>value;
    // } else if (value < 1.7014118346046e38) {
  } else if (value < reinterpret<f64>(0x47F0000000000000)) { // 2^128-1
    let lo: u64, hi: u64, m: u64;

    m = (u & 0x000FFFFFFFFFFFFF) | (1 << 52);
    u = (u & 0x7FFFFFFFFFFFFFFF) >> 52;
    u -= 1075;
    if (u > 64) {
      lo = 0;
      hi = m << (u - 64);
    } else {
      lo = m << u;
      hi = m >> (64 - u);
    }
    __res128_hi = hi;
    return lo;
  } else {
    // overflow positive
    __res128_hi = <u64>-1; // 0x7FFFFFFFFFFFFFFF for i128
    return <u64>-1;
  }
}

// @ts-ignore: decorator
@global @inline
export function __clz128(lo: u64, hi: u64): i32 {
  var mask: u64 = <i64>(hi ^ (hi - 1)) >> 63;
  return <i32>clz((hi & ~mask) | (lo & mask)) + (<i32>mask & 64);
}

// @ts-ignore: decorator
@global @inline
export function __ctz128(lo: u64, hi: u64): i32 {
  var mask: u64 = <i64>(lo ^ (lo - 1)) >> 63;
  return <i32>ctz((hi & mask) | (lo & ~mask)) + (<i32>mask & 64);
}

// @ts-ignore: decorator
@global
export function __udivmod128(alo: u64, ahi: u64, blo: u64, bhi: u64): u64 {
  var bzn = __clz128(blo, bhi); // N

  // b == 0
  if (bzn == 128) {
    throw new RangeError("Division by zero"); // division by zero
  }

  // var azn = __clz128(alo, ahi); // M
  var btz = __ctz128(blo, bhi); // N

  // a == 0
  if (!(alo | ahi)) {
    __divmod_quot_hi = 0;
    __divmod_rem_lo  = 0;
    __divmod_rem_hi  = 0;
    return 0;
  }

  // a / 1
  if (bzn == 127) {
    __divmod_quot_hi = ahi;
    __divmod_rem_lo  = 0;
    __divmod_rem_hi  = 0;
    return alo;
  }

  // a == b
  if (alo == blo && ahi == bhi) {
    __divmod_quot_hi = 0;
    __divmod_rem_lo  = 0;
    __divmod_rem_hi  = 0;
    return 1;
  }

  // if (btz + bzn == 127) {
  //   // TODO
  //   // __divmod_quot = a >> btz
  //   // b++
  //   // __divmod_rem = a & b
  //   return;
  // }

  if (!(ahi | bhi)) {
    __divmod_quot_hi = 0;
    __divmod_rem_hi  = 0;
    // if `b.lo` is power of two
    if (!(blo & (blo - 1))) {
      __divmod_rem_lo = alo & (blo - 1);
      return alo >> btz;
    } else {
      let dlo = alo / blo;
      __divmod_rem_lo = alo - dlo * blo;
      return dlo;
    }
  }

  // if b.lo == 0 and `b.hi` is power of two
  // if (!blo && !(bhi & (bhi - 1))) {
  //   __divmod_rem = 0;

  //   // TODO

  //   return 0;
  // }

  // var diff: i64 = ahi - bhi;
  // var cmp = <i32>(diff != 0 ? diff : alo - blo); // TODO optimize this

  // if (cmp <= 0) {
  //   __divmod_quot_hi = 0;
  //   __divmod_rem     = 0;
  //   return u64(cmp == 0);
  // }

  // if (bzn - azn <= 5) {
  //   // TODO
  //   // fast path
  //   return __udivmod128core(alo, ahi, blo, bhi);
  // }
  return __udivmod128core(alo, ahi, blo, bhi);
}

function __udivmod128core(alo: u64, ahi: u64, blo: u64, bhi: u64): u64 {
  var a = new u128(alo, ahi);
  var b = new u128(blo, bhi);
  // get leading zeros for left alignment
  var alz = __clz128(alo, ahi);
  var blz = __clz128(blo, bhi);
  var off = blz - alz;
  var nb  = b << off;
  var q = u128.Zero;
  var n = a.clone();

  // create a mask with the length of b
  var mask = u128.One;
  mask <<= 128 - blz;
  --mask;
  mask <<= off;

  var i = 0;
  while (n >= b) {
    ++i;
    q <<= 1;
    if ((n & mask) >= nb) {
      ++q;
      n -= nb;
    }

    mask |= mask >> 1;
    nb >>= 1;
  }
  q <<= (blz - alz - i + 1);

  __divmod_quot_hi = q.hi;
  __divmod_rem_lo  = n.lo;
  __divmod_rem_hi  = n.hi;
  return q.lo;
}

// @ts-ignore: decorator
@global
export function __udivmod128_10(lo: u64, hi: u64): u64 {
  if (!hi) {
    __divmod_quot_hi = 0;
    if (lo < 10) {
      __divmod_rem_lo = 0;
      __divmod_rem_hi = 0;
      return 0;
    } else {
      let qlo = lo / 10;
      __divmod_rem_lo = lo - qlo * 10;
      __divmod_rem_hi = 0;
      return qlo;
    }
  }

  var q: u128, r: u128;
  var n = new u128(lo, hi);

  q  = n >> 1;
  q += n >> 2;
  q += q >> 4;
  q += q >> 8;
  q += q >> 16;
  q += q >> 32;
  q += u128.fromU64(q.hi); // q >> 64
  q >>= 3;
  r = n - (((q << 2) + q) << 1);
  n = q + u128.fromBool(r.lo > 9);

  __divmod_quot_hi = n.hi;
  __divmod_rem_lo  = r.lo;
  __divmod_rem_hi  = r.hi;
  return n.lo;
}

@lazy const HEX_CHARS = '0123456789abcdef';

export class u128 {

  @inline static get Zero(): u128 { return new u128(); }
  @inline static get One():  u128 { return new u128(1); }
  @inline static get Min():  u128 { return new u128(); }
  @inline static get Max():  u128 { return new u128(-1, -1); }

  @inline
  static fromString(value: string, radix: i32 = 10): u128 {
    return atou128(value, radix);
  }

  @inline
  static fromI256(value: i256): u128 {
    return new u128(value.lo1, value.lo2);
  }

  @inline
  static fromU256(value: u256): u128 {
    return new u128(value.lo1, value.lo2);
  }

  @inline
  static fromI128(value: i128): u128 {
    return new u128(value.lo, value.hi);
  }

  @inline
  static fromU128(value: u128): u128 {
    return new u128(value.lo, value.hi);
  }

  @inline
  static fromI64(value: i64): u128 {
    return new u128(value, value >> 63);
  }

  @inline
  static fromU64(value: u64): u128 {
    return new u128(value);
  }

  // TODO need improvement
  // max safe uint for f64 actually 53-bits
  @inline
  static fromF64(value: f64): u128 {
    return new u128(<u64>value, reinterpret<i64>(value) >> 63);
  }

  // TODO need improvement
  // max safe int for f32 actually 23-bits
  @inline
  static fromF32(value: f32): u128 {
    return new u128(<u64>value, <u64>(reinterpret<i32>(value) >> 31));
  }

  @inline
  static fromI32(value: i32): u128 {
    return new u128(value, value >> 31);
  }

  @inline
  static fromU32(value: u32): u128 {
    return new u128(value);
  }

  @inline
  static fromBool(value: bool): u128 {
    return new u128(<u64>value);
  }

  @inline
  static fromBits(lo1: u32, lo2: u32, hi1: u32, hi2: u32): u128 {
    return new u128(
      <u64>lo1 | ((<u64>lo2) << 32),
      <u64>hi1 | ((<u64>hi2) << 32),
    );
  }

  @inline
  static fromBytes<T>(array: T, bigEndian: bool = false): u128 {
    if (array instanceof u8[]) {
      return bigEndian
        ? u128.fromBytesBE(<u8[]>array)
        : u128.fromBytesLE(<u8[]>array);
    } else if (array instanceof Uint8Array) {
      return bigEndian
        ? u128.fromUint8ArrayBE(<Uint8Array>array)
        : u128.fromUint8ArrayLE(<Uint8Array>array);
    } else {
      throw new TypeError("Unsupported generic type");
    }
  }

  @inline
  static fromBytesLE(array: u8[]): u128 {
    return u128.fromUint8ArrayLE(changetype<Uint8Array>(array));
  }

  @inline
  static fromBytesBE(array: u8[]): u128 {
    return u128.fromUint8ArrayBE(changetype<Uint8Array>(array));
  }

  @inline
  static fromUint8ArrayLE(array: Uint8Array): u128 {
    assert(array.length && (array.length & 15) == 0);
    // @ts-ignore
    var buffer = array.dataStart;
    return new u128(
      load<u64>(buffer, 0 * sizeof<u64>()),
      load<u64>(buffer, 1 * sizeof<u64>())
    );
  }

  @inline
  static fromUint8ArrayBE(array: Uint8Array): u128 {
    assert(array.length && (array.length & 15) == 0);
    // @ts-ignore
    var buffer = array.dataStart;
    return new u128(
      bswap<u64>(load<u64>(buffer, 1 * sizeof<u64>())),
      bswap<u64>(load<u64>(buffer, 0 * sizeof<u64>()))
    );
  }

  /**
   * Create 128-bit unsigned integer from generic type T
   * @param  value
   * @returns 128-bit unsigned integer
   */
  @inline
  static from<T>(value: T): u128 {
         if (value instanceof bool)   return u128.fromU64(<u64>value);
    else if (value instanceof i8)     return u128.fromI64(<i64>value);
    else if (value instanceof u8)     return u128.fromU64(<u64>value);
    else if (value instanceof i16)    return u128.fromI64(<i64>value);
    else if (value instanceof u16)    return u128.fromU64(<u64>value);
    else if (value instanceof i32)    return u128.fromI64(<i64>value);
    else if (value instanceof u32)    return u128.fromU64(<u64>value);
    else if (value instanceof i64)    return u128.fromI64(<i64>value);
    else if (value instanceof u64)    return u128.fromU64(<u64>value);
    else if (value instanceof f32)    return u128.fromF64(<f64>value);
    else if (value instanceof f64)    return u128.fromF64(<f64>value);
    else if (value instanceof i128)   return u128.fromI128(<i128>value);
    else if (value instanceof u128)   return u128.fromU128(<u128>value);
    else if (value instanceof i256)   return u128.fromI256(<i256>value);
    else if (value instanceof u256)   return u128.fromU256(<u256>value);
    else if (value instanceof u8[])   return u128.fromBytes(<u8[]>value);
    else if (value instanceof Uint8Array) return u128.fromBytes(<Uint8Array>value);
    else if (value instanceof String) return u128.fromString(<string>value);
    else throw new TypeError("Unsupported generic type");
  }

  /**
   * Create 128-bit unsigned integer from 64-bit parts
   * @param lo low  64-bit part of 128-bit unsigned integer
   * @param hi high 64-bit part of 128-bit unsigned integer
   */
  constructor(
    public lo: u64 = 0,
    public hi: u64 = 0,
  ) {}

  @inline
  set(value: u128): this {
    this.lo = value.lo;
    this.hi = value.hi;
    return this;
  }

  @inline
  setI64(value: i64): this {
    this.lo = value;
    this.hi = value >> 63;
    return this;
  }

  @inline
  setU64(value: u64): this {
    this.lo = value;
    this.hi = 0;
    return this;
  }

  @inline
  setI32(value: i32): this {
    this.lo = value;
    this.hi = value >> 63;
    return this;
  }

  @inline
  setU32(value: u32): this {
    this.lo = value;
    this.hi = 0;
    return this;
  }

  @inline
  isZero(): bool {
    return !(this.lo | this.hi);
  }

  @inline @operator.prefix('~')
  not(): u128 {
    return new u128(~this.lo, ~this.hi);
  }

  @inline @operator.prefix('+')
  pos(): u128 {
    return this;
  }

  @inline @operator.prefix('-')
  neg(): u128 {
    var lo = ~this.lo;
    var hi = ~this.hi;
    var lo1 = lo + 1;
    return new u128(lo1, hi + u64(lo1 < lo));
  }

  @operator.prefix('++')
  preInc(): this {
    var lo = this.lo;
    var lo1 = lo + 1;
    this.hi += u64(lo1 < lo);
    this.lo = lo1;
    return this;
  }

  @operator.prefix('--')
  preDec(): this {
    var lo = this.lo;
    var lo1 = lo - 1;
    this.hi -= u64(lo1 > lo);
    this.lo = lo1;
    return this;
  }

  @operator.postfix('++')
  postInc(): u128 {
    return this.clone().preInc();
  }

  @operator.postfix('--')
  postDec(): u128 {
    return this.clone().preDec();
  }

  @inline @operator.prefix('!')
  static isEmpty(value: u128): bool {
    return !(value.lo | value.hi);
  }

  @inline @operator('|')
  static or(a: u128, b: u128): u128 {
    return new u128(a.lo | b.lo, a.hi | b.hi);
  }

  @inline @operator('^')
  static xor(a: u128, b: u128): u128 {
    return new u128(a.lo ^ b.lo, a.hi ^ b.hi);
  }

  @inline @operator('&')
  static and(a: u128, b: u128): u128 {
    return new u128(a.lo & b.lo, a.hi & b.hi);
  }

  @inline @operator('<<')
  static shl(value: u128, shift: i32): u128 {
    shift &= 127;

    // need for preventing redundant i32 -> u64 extends
    var shift64 = shift as u64;

    var mod1 = ((((shift64 + 127) | shift64) & 64) >> 6) - 1;
    var mod2 = (shift64 >> 6) - 1;

    shift64 &= 63;

    var vl = value.lo;
    var lo = vl << shift64;
    var hi = lo & ~mod2;

    hi |= ((value.hi << shift64) | ((vl >> (64 - shift64)) & mod1)) & mod2;

    return new u128(lo & mod2, hi);
  }

  @inline @operator('>>')
  static shr(value: u128, shift: i32): u128 {
    shift &= 127;

    // need for preventing redundant i32 -> u64 extends
    var shift64 = shift as u64;

    var mod1 = ((((shift64 + 127) | shift64) & 64) >> 6) - 1;
    var mod2 = (shift64 >> 6) - 1;

    shift64 &= 63;

    var vh = value.hi;
    var hi = vh >> shift64;
    var lo = hi & ~mod2;

    lo |= ((value.lo >> shift64) | ((vh << (64 - shift64)) & mod1)) & mod2;

    return new u128(lo, hi & mod2);
  }

  @inline @operator('>>>')
  static shr_u(value: u128, shift: i32): u128 {
    return u128.shr(value, shift);
  }

  @inline
  static rotl(value: u128, shift: i32): u128 {
    let n = shift & 127;
    if (n == 0) return value.clone();

    let lo = value.lo;
    let hi = value.hi;
    if (n == 64) {
      return new u128(hi, lo);
    }
    if (n & 64) {
      let t = lo; lo = hi; hi = t;
    }
    let slo = lo << n;
    let shi = hi << n;
    let rlo = lo >> (64 - n);
    let rhi = hi >> (64 - n);
    return new u128(slo | rhi, shi | rlo);
  }

  @inline
  static rotr(value: u128, shift: i32): u128 {
    let n = shift & 127;
    if (n == 0) return value.clone();

    let lo = value.lo;
    let hi = value.hi;
    if (n == 64) {
      return new u128(hi, lo);
    }
    if (n & 64) {
      let t = lo; lo = hi; hi = t;
    }
    let slo = lo >> n;
    let shi = hi >> n;
    let rlo = lo << (64 - n);
    let rhi = hi << (64 - n);
    return new u128(slo | rhi, shi | rlo);
  }

  @inline @operator('+')
  static add(a: u128, b: u128): u128 {
    var alo = a.lo;
    var lo = alo + b.lo;
    var hi = a.hi + b.hi + u64(lo < alo);
    return new u128(lo, hi);
  }

  @inline @operator('-')
  static sub(a: u128, b: u128): u128 {
    var alo = a.lo;
    var lo = alo - b.lo;
    var hi = a.hi - b.hi - u64(lo > alo);
    return new u128(lo, hi);
  }

  // mul: u128 x u128 = u128
  @inline @operator('*')
  static mul(a: u128, b: u128): u128 {
    return new u128(
      __multi3(a.lo, a.hi, b.lo, b.hi),
      __res128_hi
    );
  }

  @inline @operator('/')
  static div(a: u128, b: u128): u128 {
    return new u128(
      __udivmod128(a.lo, a.hi, b.lo, b.hi),
      __divmod_quot_hi
    );
  }

  @inline @operator('%')
  static rem(a: u128, b: u128): u128 {
    __udivmod128(a.lo, a.hi, b.lo, b.hi);
    return new u128(__divmod_rem_lo, __divmod_rem_hi);
  }

  @inline
  static div10(value: u128): u128 {
    return new u128(
      __udivmod128_10(value.lo, value.hi),
      __divmod_quot_hi
    );
  }

  @inline
  static rem10(value: u128): u128 {
    __udivmod128_10(value.lo, value.hi);
    return new u128(__divmod_rem_lo, __divmod_rem_hi);
  }

  /**
   * Calculate power of base with exponent
   * @param  base     128-bit unsigned integer
   * @param  exponent 32-bit signed integer
   * @returns         128-bit unsigned integer
   */
  @operator('**')
  static pow(base: u128, exponent: i32): u128 {
    // any negative exponent produce zero

    var result = u128.One;

    if (base == result) return result;
    var tmp = base.clone();
    if (exponent <= 1) {
      if (exponent < 0) return u128.Zero;
      return exponent == 0 ? result : tmp;
    }

    if (ASC_SHRINK_LEVEL < 1) {
      var lo = base.lo;
      var hi = base.hi;
      // if base > u64::max and exp > 1 always return "0"
      if (!lo) return u128.Zero;
      if (!hi) {
        let lo1 = lo - 1;
        // "1 ^ exponent" always return "1"
        if (!lo1) return result;

        // if base is power of two do "1 << log2(base) * exp"
        if (!(lo & lo1)) {
          let shift = <i32>(64 - clz(lo1)) * exponent;
          // @ts-ignore
          return shift < 128 ? result << shift : u128.Zero;
        }
      }

      if (exponent <= 4) {
        let baseSq = tmp.sqr();
        switch (exponent) {
          case 2: return baseSq;        // base ^ 2
          // @ts-ignore
          case 3: return baseSq * base; // base ^ 2 * base
          case 4: return baseSq.sqr();  // base ^ 2 * base ^ 2
          default: break;
        }
      }

      let log = 32 - clz(exponent);
      if (log <= 7) {
        // 128 = 2 ^ 7, so need usually only seven cases
        switch (log) {
          case 7:
            // @ts-ignore
            if (exponent & 1) result *= tmp;
            exponent >>= 1;
            tmp.sqr();
          case 6:
            // @ts-ignore
            if (exponent & 1) result *= tmp;
            exponent >>= 1;
            tmp.sqr();
          case 5:
            // @ts-ignore
            if (exponent & 1) result *= tmp;
            exponent >>= 1;
            tmp.sqr();
          case 4:
            // @ts-ignore
            if (exponent & 1) result *= tmp;
            exponent >>= 1;
            tmp.sqr();
          case 3:
            // @ts-ignore
            if (exponent & 1) result *= tmp;
            exponent >>= 1;
            tmp.sqr();
          case 2:
            // @ts-ignore
            if (exponent & 1) result *= tmp;
            exponent >>= 1;
            tmp.sqr();
          case 1:
            // @ts-ignore
            if (exponent & 1) result *= tmp;
        }
        return result;
      }
    }

    while (exponent > 0) {
      // @ts-ignore
      if (exponent & 1) result *= tmp;
      exponent >>= 1;
      tmp.sqr();
    }
    return result;
  }

  // compute floor(sqrt(x))
  static sqrt(value: u128): u128 {
    var rem = value.clone();
    if (value < new u128(2)) {
      return rem;
    }
    var res = u128.Zero;
    // @ts-ignore
    var pos = u128.One << (127 - (u128.clz(value) | 1));
    // @ts-ignore
    while (!pos.isZero()) {
      // @ts-ignore
      value = res + pos;
      if (rem >= value) {
        // @ts-ignore
        rem = rem - value;
        // @ts-ignore
        res = pos + value;
      }
      // @ts-ignore
      res >>= 1;
      pos >>= 2;
    }
    return res;
  }

  @inline @operator('==')
  static eq(a: u128, b: u128): bool {
    return a.hi == b.hi && a.lo == b.lo;
  }

  @inline @operator('!=')
  static ne(a: u128, b: u128): bool {
    return !u128.eq(a, b);
  }

  @inline @operator('<')
  static lt(a: u128, b: u128): bool {
    var ah = a.hi, bh = b.hi;
    return ah == bh ? a.lo < b.lo : ah < bh;
  }

  @inline @operator('>')
  static gt(a: u128, b: u128): bool {
    var ah = a.hi, bh = b.hi;
    return ah == bh ? a.lo > b.lo : ah > bh;
  }

  @inline @operator('<=')
  static le(a: u128, b: u128): bool {
    return !u128.gt(a, b);
  }

  @inline @operator('>=')
  static ge(a: u128, b: u128): bool {
    return !u128.lt(a, b);
  }

   /**
   * Get ordering
   * if a > b then result is  1
   * if a < b then result is -1
   * if a = b then result is  0
   * @param  a 128-bit unsigned integer
   * @param  b 128-bit unsigned integer
   * @returns  32-bit signed integer
   */
  @inline
  static ord(a: u128, b: u128): i32 {
    var dlo = a.lo - b.lo;
    var dhi = a.hi - b.hi;
    var cmp = <i32>select<i64>(dhi, dlo, dhi != 0);
    // normalize to [-1, 0, 1]
    return i32(cmp > 0) - i32(cmp < 0);
  }

  /**
   * Compute count of set (populated) bits
   * @param  value 128-bit unsigned integer
   * @returns      32-bit signed integer
   */
  @inline
  static popcnt(value: u128): i32 {
    return <i32>(popcnt(value.lo) + popcnt(value.hi));
  }

  /**
   * Compute bit count of leading zeros
   * @param  value 128-bit unsigned integer
   * @returns      32-bit signed integer
   */
  @inline
  static clz(value: u128): i32 {
    return __clz128(value.lo, value.hi);
  }

  /**
   * Compute bit count of trailing zeros
   * @param  value 128-bit unsigned integer
   * @returns      32-bit signed integer
   */
  @inline
  static ctz(value: u128): i32 {
    return __ctz128(value.lo, value.hi);
  }

  /**
   * Calculate squared value (value ** 2)
   * @param  value 128-bit unsigned integer
   * @returns      128-bit unsigned integer
   */
  @inline
  static sqr(value: u128): u128 {
    return value.clone().sqr();
  }

  /**
   * Calculate inplace squared 128-bit unsigned integer (this ** 2)
   * @returns 128-bit unsigned integer
   */
  sqr(): this {
    var u = this.lo,
        v = this.hi;

    var u1 = u & 0xFFFFFFFF;
    var t  = u1 * u1;
    var w  = t & 0xFFFFFFFF;
    var k  = t >> 32;

    u >>= 32;
    var m = u * u1;
    t = m + k;
    var w1 = t >> 32;

    t = m + (t & 0xFFFFFFFF);

    var lo = (t << 32) + w;
    var hi  = u * u;
        hi += w1 + (t >> 32);
        hi += u * v << 1;

    this.lo = lo;
    this.hi = hi;

    return this;
  }

  /**
   * Calculate multiply and division as `number * numerator / denominator`
   * without overflow in multiplication part.
   *
   * @returns 128-bit unsigned integer
   */
  static muldiv(number: u128, numerator: u128, denominator: u128): u128 {
    let a = number;
    let b = numerator;
    let c = denominator;

    let ql = __udivmod128(b.lo, b.hi, c.lo, c.hi);

    let qn = new u128(ql, __divmod_quot_hi);             // b / c
    let rn = new u128(__divmod_rem_lo, __divmod_rem_hi); // b % c

    let q = u128.Zero;
    let r = u128.Zero;
    let n = a.clone();

    while (!n.isZero()) {
      if (n.lo & 1) {
        // @ts-ignore
        q += qn;
        // @ts-ignore
        r += rn;
        if (r >= c) {
          // @ts-ignore
          ++q;
          // @ts-ignore
          r -= c;
        }
      }
      // @ts-ignore
      n >>= 1;
      // @ts-ignore
      qn <<= 1;
      // @ts-ignore
      rn <<= 1;

      if (rn >= c) {
        // @ts-ignore
        ++qn;
        // @ts-ignore
        rn -= c;
      }
    }
    return q;
  }

  /**
  * Convert to 256-bit signed integer
  * @returns 256-bit signed integer
  */
  @inline
  toI256(): i256 {
    return new i256(this.lo, this.hi);
  }

  /**
  * Convert to 256-bit unsigned integer
  * @returns 256-bit unsigned integer
  */
  @inline
  toU256(): u256 {
    return new u256(this.lo, this.hi);
  }

  /**
  * Convert to 128-bit signed integer
  * @returns 128-bit signed integer
  */
  @inline
  toI128(): i128 {
    return new i128(this.lo, this.hi);
  }

  /**
  * Convert to 128-bit unsigned integer
  * @returns 128-bit unsigned integer
  */
  @inline
  toU128(): this {
    return this;
  }

  /**
  * Convert to 64-bit signed integer
  * @returns 64-bit signed integer
  */
  @inline
  toI64(): i64 {
    return <i64>(
      (this.lo & 0x7FFFFFFFFFFFFFFF) |
      (this.hi & 0x8000000000000000)
    );
  }

  /**
  * Convert to 64-bit unsigned integer
  * @returns 64-bit unsigned integer
  */
  @inline
  toU64(): u64 {
    return this.lo;
  }

  /**
  * Convert to 32-bit signed integer
  * @returns 32-bit signed integer
  */
  @inline
  toI32(): i32 {
    return <i32>this.toI64();
  }

  /**
  * Convert to 32-bit unsigned integer
  * @returns 32-bit unsigned integer
  */
  @inline
  toU32(): u32 {
    return <u32>this.lo;
  }

  /**
  * Convert to 1-bit boolean
  * @returns 1-bit boolean
  */
  @inline
  toBool(): bool {
    return (this.lo | this.hi) != 0;
  }

  /**
  * Convert to 64-bit float number in deteministic way
  * @returns 64-bit float
  */
  @inline
  toF64(): f64 {
    return __floatuntidf(this.lo, this.hi);
  }

  /**
  * Convert to 32-bit float number
  * @returns 32-bit float
  */
  @inline
  toF32(): f32 {
    return <f32>this.toF64();
  }

  /**
   * Convert to generic type `T`. Useful inside other generics methods
   * @param  T  is <bool | i8 | u8 | i16 | u16 | i32 | u32 | i64 | u64 | f32 | f64 | i128 | u128 | u256 | u8[] | Uint8Array | `StaticArray<u8>` | string>
   * @returns   type of `T`
   */
  @inline
  as<T>(): T {
    if (isBoolean<T>()) {
      return <T>this.toBool();
    }
    else if (isInteger<T>()) {
      if (isSigned<T>()) {
        // i8, i16, i32, i64
        return <T>this.toI64();
      } else {
        // u8, u16, u32, u64
        return <T>this.toU64();
      }
    }
    else if (isFloat<T>()) {
      // f32, f64
      return <T>this.toF64();
    }
    else if (isString<T>()) {
      return <T>this.toString();
    }
    else if (isReference<T>()) {
      let dummy = changetype<T>(0);
           if (dummy instanceof u8[]) return <T>this.toBytes();
      else if (dummy instanceof StaticArray<u8>) return <T>this.toStaticBytes();
      else if (dummy instanceof Uint8Array) return <T>this.toUint8Array();
      else if (dummy instanceof i128) return <T>this.toI128();
      else if (dummy instanceof u128) return <T>this;
      else if (dummy instanceof u256) return <T>this.toU256();
      else throw new TypeError('Unsupported generic type');
    }
    else throw new TypeError('Unsupported generic type');
  }

  @inline
  private toArrayBufferLE(buffer: usize): void {
    store<u64>(buffer, this.lo, 0 * sizeof<u64>());
    store<u64>(buffer, this.hi, 1 * sizeof<u64>());
  }

  @inline
  private toArrayBufferBE(buffer: usize): void {
    store<u64>(buffer, bswap(this.hi), 0 * sizeof<u64>());
    store<u64>(buffer, bswap(this.lo), 1 * sizeof<u64>());
  }

  @inline
  private toArrayBuffer(buffer: usize, bigEndian: bool = false): void {
    if (bigEndian) {
      this.toArrayBufferBE(buffer);
    } else {
      this.toArrayBufferLE(buffer);
    }
  }

  /**
   * Convert to byte array
   * @param bigEndian Little or Big Endian? Default: false
   * @returns  Array of bytes
   */
  @inline
  toBytes(bigEndian: bool = false): u8[] {
    var result = new Array<u8>(16);
    this.toArrayBuffer(result.dataStart, bigEndian);
    return result;
  }

    /**
   * Convert to byte static array
   * @param bigEndian Little or Big Endian? Default: false
   * @returns  StaticArray of bytes
   */
    @inline
    toStaticBytes(bigEndian: bool = false): StaticArray<u8> {
      var result = new StaticArray<u8>(16);
      this.toArrayBuffer(changetype<usize>(result), bigEndian);
      return result;
    }

  /**
   * Convert to Uint8Array
   * @param bigEndian Little or Big Endian? Default: false
   * @returns  Uint8Array
   */
  @inline
  toUint8Array(bigEndian: bool = false): Uint8Array {
    var result = new Uint8Array(16);
    this.toArrayBuffer(result.dataStart, bigEndian);
    return result;
  }

  /**
  * Return copy of current 128-bit value
  * @returns 128-bit unsigned integer
  */
  clone(): u128 {
    return new u128(this.lo, this.hi);
  }

  toString(radix: i32 = 10): string {
    assert(radix == 10 || radix == 16, 'radix argument must be between 10 or 16');
    if (this.isZero()) return '0';

    var result = '';
    if (radix == 16) {
      let shift: i32 = 124 - (u128.clz(this) & ~3);
      while (shift >= 0) {
        // @ts-ignore
        result += HEX_CHARS.charAt(<i32>((this >> shift).lo & 15));
        shift  -= 4;
      }
      return result;
    }
    return u128toDecimalString(this);
  }
}

export class u256 {

  @inline static get Zero(): u256 { return new u256(); }
  @inline static get One():  u256 { return new u256(1); }
  @inline static get Min():  u256 { return new u256(); }
  @inline static get Max():  u256 { return new u256(-1, -1, -1, -1); }

  // TODO: fromString

  @inline
  static fromU256(value: u256): u256 {
    return new u256(value.lo1, value.lo2, value.hi1, value.hi2);
  }

  @inline
  static fromU128(value: u128): u256 {
    return new u256(value.lo, value.hi);
  }

  @inline
  static fromU64(value: u64): u256 {
    return new u256(value);
  }

  @inline
  static fromI64(value: i64): u256 {
    var mask = value >> 63;
    return new u256(value, mask, mask, mask);
  }

  @inline
  static fromU32(value: u32): u256 {
    return new u256(value);
  }

  @inline
  static fromI32(value: i32): u256 {
    var mask: u64 = value >> 63;
    return new u256(value, mask, mask, mask);
  }

  @inline
  static fromBits(
    l0: u32, l1: u32, l2: u32, l3: u32,
    h0: u32, h1: u32, h2: u32, h3: u32,
  ): u256 {
    return new u256(
      <u64>l0 | ((<u64>l1) << 32),
      <u64>l2 | ((<u64>l3) << 32),
      <u64>h0 | ((<u64>h1) << 32),
      <u64>h2 | ((<u64>h3) << 32),
    );
  }

  @inline
  static fromBytes<T>(array: T, bigEndian: bool = false): u256 {
    // @ts-ignore
    if (array instanceof u8[]) {
      return bigEndian
        // @ts-ignore
        ? u256.fromBytesBE(<u8[]>array)
        // @ts-ignore
        : u256.fromBytesLE(<u8[]>array);
    } else if (array instanceof Uint8Array) {
      return bigEndian
        ? u256.fromUint8ArrayBE(<Uint8Array>array)
        : u256.fromUint8ArrayLE(<Uint8Array>array);
    } else {
      throw new TypeError("Unsupported generic type");
    }
  }

  @inline
  static fromBytesLE(array: u8[]): u256 {
    assert(array.length && (array.length & 31) == 0);
    // @ts-ignore
    var buffer = array.dataStart
    return new u256(
      load<u64>(buffer, 0 * sizeof<u64>()),
      load<u64>(buffer, 1 * sizeof<u64>()),
      load<u64>(buffer, 2 * sizeof<u64>()),
      load<u64>(buffer, 3 * sizeof<u64>()),
    );
  }

  @inline
  static fromBytesBE(array: u8[]): u256 {
    assert(array.length && (array.length & 31) == 0);
    var buffer = array.dataStart;
    return new u256(
      bswap<u64>(load<u64>(buffer, 3 * sizeof<u64>())),
      bswap<u64>(load<u64>(buffer, 2 * sizeof<u64>())),
      bswap<u64>(load<u64>(buffer, 1 * sizeof<u64>())),
      bswap<u64>(load<u64>(buffer, 0 * sizeof<u64>()))
    );
  }

  @inline
  static fromUint8ArrayLE(array: Uint8Array): u256 {
    assert(array.length && (array.length & 31) == 0);
    var buffer = array.dataStart;
    return new u256(
        load<u64>(buffer, 0 * sizeof<u64>()),
        load<u64>(buffer, 1 * sizeof<u64>()),
        load<u64>(buffer, 2 * sizeof<u64>()),
        load<u64>(buffer, 3 * sizeof<u64>())
    );
  }

  @inline
  static fromUint8ArrayBE(array: Uint8Array): u256 {
    assert(array.length && (array.length & 31) == 0);
    var buffer = array.dataStart;
    return new u256(
        bswap<u64>(load<u64>(buffer, 3 * sizeof<u64>())),
        bswap<u64>(load<u64>(buffer, 2 * sizeof<u64>())),
        bswap<u64>(load<u64>(buffer, 1 * sizeof<u64>())),
        bswap<u64>(load<u64>(buffer, 0 * sizeof<u64>()))
    );
  }

  // TODO need improvement
  // max safe uint for f64 actually 52-bits
  @inline
  static fromF64(value: f64): u256 {
    var mask = u64(reinterpret<i64>(value) >> 63);
    return new u256(<u64>value, mask, mask, mask);
  }

  // TODO need improvement
  // max safe int for f32 actually 23-bits
  @inline
  static fromF32(value: f32): u256 {
    var mask = u64(reinterpret<i32>(value) >> 31);
    return new u256(<u64>value, mask, mask, mask);
  }

  // TODO
  // static fromString(str: string): u256

  constructor(
    public lo1: u64 = 0,
    public lo2: u64 = 0,
    public hi1: u64 = 0,
    public hi2: u64 = 0,
  ) {}

  @inline
  set(value: u256): this {
    this.lo1 = value.lo1;
    this.lo2 = value.lo2;
    this.hi1 = value.hi1;
    this.hi2 = value.hi2;
    return this;
  }

  @inline
  setU128(value: u128): this {
    this.lo1 = value.lo;
    this.lo2 = value.hi;
    this.hi1 = 0;
    this.hi2 = 0;
    return this;
  }

  @inline
  setI64(value: i64): this {
    var mask: u64 = value >> 63;
    this.lo1 = value;
    this.lo2 = mask;
    this.hi1 = mask;
    this.hi2 = mask;
    return this;
  }

  @inline
  setU64(value: u64): this {
    this.lo1 = value;
    this.lo2 = 0;
    this.hi1 = 0;
    this.hi2 = 0;
    return this;
  }

  @inline
  setI32(value: i32): this {
    var mask: u64 = value >> 63;
    this.lo1 = value;
    this.lo2 = mask;
    this.hi1 = mask;
    this.hi2 = mask;
    return this;
  }

  @inline
  setU32(value: u32): this {
    this.lo1 = value;
    this.lo2 = 0;
    this.hi1 = 0;
    this.hi2 = 0;
    return this;
  }

  @inline
  isZero(): bool {
    return !(this.lo1 | this.lo2 | this.hi1 | this.hi2);
  }

  @inline @operator.prefix('!')
  static isEmpty(value: u256): bool {
    return value.isZero();
  }

  @inline @operator.prefix('~')
  not(): u256 {
    return new u256(~this.lo1, ~this.lo2, ~this.hi1, ~this.hi2);
  }

  @inline @operator.prefix('+')
  pos(): u256 {
    return this;
  }

  @operator.prefix('-')
  neg(): u256 {
    var
      lo1 = ~this.lo1,
      lo2 = ~this.lo2,
      hi1 = ~this.hi1,
      hi2 = ~this.hi2;

    var lo1p = lo1 + 1;
    var lo2p = lo2 + u64(lo1p < lo1);
    var hi1p = hi1 + ((lo2 & ~lo2p) >> 63);
    var hi2p = hi2 + ((hi1 & ~hi1p) >> 63);

    return new u256(lo1p, lo2p, hi1p, hi2p);
  }

  @operator.prefix('++')
  preInc(): this {
    var
      lo1 = this.lo1,
      lo2 = this.lo2,
      hi1 = this.hi1,
      hi2 = this.hi2;

    var lo1p = lo1 + 1;
    var lo2p = lo2 + u64(lo1p < lo1);
    var hi1p = hi1 + ((lo2 & ~lo2p) >> 63);
    var hi2p = hi2 + ((hi1 & ~hi1p) >> 63);

    this.lo1 = lo1p;
    this.lo2 = lo2p;
    this.hi1 = hi1p;
    this.hi2 = hi2p;

    return this;
  }

  @operator.prefix('--')
  preDec(): this {
    var
      lo1 = this.lo1,
      lo2 = this.lo2,
      hi1 = this.hi1,
      hi2 = this.hi2;

    var lo1p = lo1 - 1;
    var lo2p = lo2 - u64(lo1p > lo1);
    var hi1p = hi1 - ((~lo2 & lo2p) >> 63);
    var hi2p = hi2 - ((~hi1 & hi1p) >> 63);

    this.lo1 = lo1p;
    this.lo2 = lo2p;
    this.hi1 = hi1p;
    this.hi2 = hi2p;

    return this;
  }

  @inline @operator.postfix('++')
  postInc(): u256 {
    return this.clone().preInc();
  }

  @inline @operator.postfix('--')
  postDec(): u256 {
    return this.clone().preDec();
  }

  @operator('+')
  static add(a: u256, b: u256): u256 {
    var
      lo1a = a.lo1,
      lo2a = a.lo2,
      hi1a = a.hi1,
      hi2a = a.hi2;

    var
      lo1b = b.lo1,
      lo2b = b.lo2,
      hi1b = b.hi1,
      hi2b = b.hi2;

    var lo1 = lo1a + lo1b;
    var cy  = u64(lo1 < lo1a);
    var lo2 = lo2a + lo2b + cy;
        // for a + b + c case we should calculate carry bit differently
        cy  = ((lo2a & lo2b) | ((lo2a | lo2b) & ~lo2)) >> 63;
    var hi1 = hi1a + hi1b + cy;
        cy  = ((hi1a & hi1b) | ((hi1a | hi1b) & ~hi1)) >> 63;
    var hi2 = hi2a + hi2b + cy;
    return new u256(lo1, lo2, hi1, hi2);
  }

  @operator('-')
  static sub(a: u256, b: u256): u256 {
    var
      lo1a = a.lo1,
      lo2a = a.lo2,
      hi1a = a.hi1,
      hi2a = a.hi2;

    var
      lo1b = b.lo1,
      lo2b = b.lo2,
      hi1b = b.hi1,
      hi2b = b.hi2;

    var lo1 = lo1a - lo1b;
    var cy  = u64(lo1 > lo1a);
    var lo2 = lo2a - lo2b - cy;
        // for a - b - c case we should calculate carry bit differently
        cy  = ((~lo2a & lo2b) | ((~lo2a | lo2b) & lo2)) >> 63;
    var hi1 = hi1a - hi1b - cy;
        cy  = ((~hi1a & hi1b) | ((~hi1a | hi1b) & hi1)) >> 63;
    var hi2 = hi2a - hi2b - cy;
    return new u256(lo1, lo2, hi1, hi2);
  }

  @inline @operator('|')
  static or(a: u256, b: u256): u256 {
    return new u256(a.lo1 | b.lo1, a.lo2 | b.lo2, a.hi1 | b.hi1, a.hi2 | b.hi2);
  }

  @inline @operator('^')
  static xor(a: u256, b: u256): u256 {
    return new u256(a.lo1 ^ b.lo1, a.lo2 ^ b.lo2, a.hi1 ^ b.hi1, a.hi2 ^ b.hi2);
  }

  @inline @operator('&')
  static and(a: u256, b: u256): u256 {
    return new u256(a.lo1 & b.lo1, a.lo2 & b.lo2, a.hi1 & b.hi1, a.hi2 & b.hi2);
  }

  @operator('>>')
  static shr(value: u256, shift: i32): u256 {
    shift &= 255;
    var off = shift as u64;
    if (shift <= 64) {
      if (shift == 0) return value;
      let hi2 =  value.hi2 >> off;
      let hi1 = (value.hi1 >> off) | (value.hi2 << 64 - off);
      let lo2 = (value.lo2 >> off) | (value.hi1 << 64 - off);
      let lo1 = (value.lo1 >> off) | (value.lo2 << 64 - off);
      return new u256(lo1, lo2, hi1, hi2);
    } else if (shift > 64 && shift <= 128) {
      let hi1 = value.hi2 >> 128 - off;
      return new u256(value.lo2, value.hi1, hi1);
    } else if (shift > 128 && shift <= 192) {
      let lo2 = value.hi2 >> 192 - off;
      return new u256(value.hi1, lo2);
    } else {
      return new u256(value.hi2 >> 256 - off);
    }
  }

  @inline @operator('>>>')
  static shr_u(value: u256, shift: i32): u256 {
    return u256.shr(value, shift);
  }

  @inline @operator('==')
  static eq(a: u256, b: u256): bool {
    return (
      a.lo1 == b.lo1 && a.lo2 == b.lo2 &&
      a.hi1 == b.hi1 && a.hi2 == b.hi2
    );
  }

  @inline @operator('!=')
  static ne(a: u256, b: u256): bool {
    return !u256.eq(a, b);
  }

  @operator('<')
  static lt(a: u256, b: u256): bool {
    var ah2 = a.hi2, ah1 = a.hi1,
        bh2 = b.hi2, bh1 = b.hi1,
        al2 = a.lo2, bl2 = b.lo2;
    if (ah2 == bh2) {
      if (ah1 == bh1) {
        return al2 == bl2 ? a.lo1 < b.lo1 : al2 < bl2
      } else {
        return ah1 < bh1;
      }
    } else {
      return ah2 < bh2;
    }
  }

  @inline @operator('>')
  static gt(a: u256, b: u256): bool {
    return b < a;
  }

  @inline @operator('<=')
  static le(a: u256, b: u256): bool {
    return !u256.gt(a, b);
  }

  @inline @operator('>=')
  static ge(a: u256, b: u256): bool {
    return !u256.lt(a, b);
  }

  @inline
  static popcnt(value: u256): i32 {
    var count = popcnt(value.lo1);
    if (value.lo2) count += popcnt(value.lo2);
    if (value.hi1) count += popcnt(value.hi1);
    if (value.hi2) count += popcnt(value.hi2);
    return <i32>count;
  }

  @inline
  static clz(value: u256): i32 {
         if (value.hi2) return <i32>(clz(value.hi2) + 0);
    else if (value.hi1) return <i32>(clz(value.hi1) + 64);
    else if (value.lo2) return <i32>(clz(value.lo2) + 128);
    else                return <i32>(clz(value.lo1) + 192);
  }

  @inline
  static ctz(value: u256): i32 {
         if (value.lo1) return <i32>(ctz(value.lo1) + 0);
    else if (value.lo2) return <i32>(ctz(value.lo2) + 64);
    else if (value.hi1) return <i32>(ctz(value.hi1) + 128);
    else                return <i32>(ctz(value.hi2) + 192);
  }

  /**
   * Convert to 128-bit signed integer
   * @return 256-bit signed integer
   */
  @inline
  toI128(): i128 {
    return new i128(
      this.lo1,
      (this.lo2 & 0x7FFFFFFFFFFFFFFF) |
      (this.hi2 & 0x8000000000000000)
    );
  }

  /**
   * Convert to 128-bit unsigned integer
   * @return 128-bit unsigned integer
   */
  @inline
  toU128(): u128 {
    return new u128(this.lo1, this.lo2);
  }

  /**
  * Convert to 256-bit unsigned integer
  * @returns 256-bit unsigned integer
  */
  @inline
  toU256(): this {
    return this;
  }

  /**
   * Convert to 64-bit signed integer
   * @return 64-bit signed integer
   */
  @inline
  toI64(): i64 {
    return <i64>(
      (this.lo1 & 0x7FFFFFFFFFFFFFFF) |
      (this.hi2 & 0x8000000000000000)
    );
  }

  /**
   * Convert to 64-bit unsigned integer
   * @return 64-bit unsigned integer
   */
  @inline
  toU64(): u64 {
    return this.lo1;
  }

  /**
   * Convert to 32-bit signed integer
   * @return 32-bit signed integer
   */
  @inline
  toI32(): i32 {
    return <i32>this.toI64();
  }

  /**
   * Convert to 32-bit unsigned integer
   * @return 32-bit unsigned integer
   */
  @inline
  toU32(): u32 {
    return <u32>this.lo1;
  }

  /**
   * Convert to 1-bit boolean
   * @return 1-bit boolean
   */
  @inline
  toBool(): bool {
    return <bool>(this.lo1 | this.lo2 | this.hi1 | this.hi2);
  }

  @inline
  private toArrayBufferLE(buffer: usize): void {
    store<u64>(buffer, this.lo1, 0 * sizeof<u64>());
    store<u64>(buffer, this.lo2, 1 * sizeof<u64>());
    store<u64>(buffer, this.hi1, 2 * sizeof<u64>());
    store<u64>(buffer, this.hi2, 3 * sizeof<u64>());
  }

  @inline
  private toArrayBufferBE(buffer: usize): void {
    store<u64>(buffer, bswap(this.hi2), 0 * sizeof<u64>());
    store<u64>(buffer, bswap(this.hi1), 1 * sizeof<u64>());
    store<u64>(buffer, bswap(this.lo2), 2 * sizeof<u64>());
    store<u64>(buffer, bswap(this.lo1), 3 * sizeof<u64>());
  }

  @inline
  private toArrayBuffer(buffer: usize, bigEndian: bool = false): void {
    if (bigEndian) {
      this.toArrayBufferBE(buffer);
    } else {
      this.toArrayBufferLE(buffer);
    }
  }

  /**
   * Convert to generic type `T`. Useful inside other generics methods
   * @param  T  is <bool | i8 | u8 | i16 | u16 | i32 | u32 | i64 | u64 | f32 | f64 | i128 | u128 | u256 | u8[] | Uint8Array | `StaticArray<u8>` | string>
   * @returns   type of `T`
   */
  @inline
  as<T>(): T {
    var dummy!: T;
         if (dummy instanceof bool)       return <T>this.toBool();
    else if (dummy instanceof i8)         return <T>this.toI64();
    else if (dummy instanceof u8)         return <T>this.toU64();
    else if (dummy instanceof i16)        return <T>this.toI64();
    else if (dummy instanceof u16)        return <T>this.toU64();
    else if (dummy instanceof i32)        return <T>this.toI64();
    else if (dummy instanceof i64)        return <T>this.toI64();
    else if (dummy instanceof u32)        return <T>this.toU64();
    else if (dummy instanceof u64)        return <T>this.toU64();
    // else if (dummy instanceof f32)        return <T>this.toF64();
    // else if (dummy instanceof f64)        return <T>this.toF64();
    else if (dummy instanceof i128)       return <T>this.toI128();
    else if (dummy instanceof u128)       return <T>this.toU128();
    else if (dummy instanceof u256)       return <T>this.toU256();
    else if (dummy instanceof u8[])       return <T>this.toBytes();
    else if (dummy instanceof Uint8Array) return <T>this.toUint8Array();
    else if (dummy instanceof StaticArray<u8>) return <T>this.toStaticBytes();
    else if (dummy instanceof String)     return <T>this.toString();
    else throw new TypeError('Unsupported generic type');
  }

  /**
   * Convert to byte array
   * @param bigEndian Little or Big Endian? Default: false
   * @returns  Array of bytes
   */
  @inline
  toBytes(bigEndian: bool = false): u8[] {
    var result = new Array<u8>(32);
    this.toArrayBuffer(result.dataStart, bigEndian);
    return result;
  }

  /**
   * Convert to byte static array
   * @param bigEndian Little or Big Endian? Default: false
   * @returns  StaticArray of bytes
   */
   @inline
   toStaticBytes(bigEndian: bool = false): StaticArray<u8> {
     var result = new StaticArray<u8>(32);
     this.toArrayBuffer(changetype<usize>(result), bigEndian);
     return result;
   }

  /**
   * Convert to Uint8Array
   * @param bigEndian Little or Big Endian? Default: false
   * @returns  Uint8Array
   */
  @inline
  toUint8Array(bigEndian: bool = false): Uint8Array {
    var result = new Uint8Array(32);
    this.toArrayBuffer(result.dataStart, bigEndian);
    return result;
  }

  clone(): u256 {
    return new u256(this.lo1, this.lo2, this.hi1, this.hi2);
  }

  toString(radix: i32 = 10): string {
    assert(radix == 10 || radix == 16, 'radix argument must be between 10 or 16');
    if (this.isZero()) return '0';

    var result = '';
    if (radix == 16) {
      let shift: i32 = 252 - (u256.clz(this) & ~3);
      while (shift >= 0) {
        // @ts-ignore
        result += HEX_CHARS.charAt(<i32>((this >> shift).lo1 & 15));
        shift -= 4;
      }
      return result;
    }
    return u256toDecimalString(this);
  }
}


export class i256 {

    @inline static get Zero(): i256 { return new i256(); }
    @inline static get One():  i256 { return new i256(1); }
    @inline static get Min():  i256 { return new i256(0, 0, 0, 0x8000000000000000); }
    @inline static get Max():  i256 { return new i256(u64.MAX_VALUE, u64.MAX_VALUE, u64.MAX_VALUE, 0x7FFFFFFFFFFFFFFF); }

    constructor(
      public lo1: i64 = 0,
      public lo2: i64 = 0,
      public hi1: i64 = 0,
      public hi2: i64 = 0,
    ) {}

    @inline
    isNeg(): bool {
      return <bool>(this.hi2 >>> 63);
    }

    @inline
    isZero(): bool {
      return !(this.lo1 | this.lo2 | this.hi1 | this.hi2);
    }

    @inline @operator.prefix('!')
    static isEmpty(value: i256): bool {
      return !value.isZero();
    }

    /*
    @inline
    static abs(value: i128): i128 {
      return value < 0 ? value.neg() : value;
    }
    */

    // TODO
  }


export class i128 {

  @inline static get Zero(): i128 { return new i128(); }
  @inline static get One():  i128 { return new i128(1); }
  @inline static get Min():  i128 { return new i128(0, 0x8000000000000000); }
  @inline static get Max():  i128 { return new i128(u64.MAX_VALUE, 0x7FFFFFFFFFFFFFFF); }

  @inline
  static fromString(value: string, radix: i32 = 10): i128 {
    return changetype<i128>(atou128(value, radix));
  }

  @inline
  static fromI256(value: i256): i128 {
    return new i128(value.lo1, value.lo2);
  }

  @inline
  static fromU256(value: u256): i128 {
    return new i128(value.lo1, <i64>value.lo2);
  }

  @inline
  static fromI128(value: i128): i128 {
    return new i128(value.lo, value.hi);
  }

  @inline
  static fromU128(value: u128): i128 {
    return new i128(value.lo, <i64>value.hi);
  }

  @inline
  static fromI64(value: i64): i128 {
    return new i128(<u64>value, value >> 63);
  }

  @inline
  static fromU64(value: u64): i128 {
    return new i128(value);
  }

  // TODO need improvement
  // max safe uint for f64 actually 53-bits
  @inline
  static fromF64(value: f64): i128 {
    return new i128(<u64>value, reinterpret<i64>(value) >> 63);
  }

  // TODO need improvement
  // max safe int for f32 actually 23-bits
  @inline
  static fromF32(value: f32): i128 {
    return new i128(<u64>value, <i64>(reinterpret<i32>(value) >> 31));
  }

  @inline
  static fromI32(value: i32): i128 {
    return new i128(<u64>value, <i64>(value >> 31));
  }

  @inline
  static fromU32(value: u32): i128 {
    return new i128(<u64>value);
  }

  @inline
  static fromBits(lo1: i32, lo2: i32, hi1: i32, hi2: i32): i128 {
    return new i128(
      <u64>lo1 | ((<u64>lo2) << 32),
      <i64>hi1 | ((<i64>hi2) << 32),
    );
  }

  @inline
  static fromBytes<T>(array: T, bigEndian: bool = false): i128 {
    if (array instanceof u8[]) {
      return bigEndian
        // @ts-ignore
        ? i128.fromBytesBE(<u8[]>array)
        // @ts-ignore
        : i128.fromBytesLE(<u8[]>array);
    } else if (array instanceof Uint8Array) {
      return bigEndian
        ? i128.fromUint8ArrayBE(<Uint8Array>array)
        : i128.fromUint8ArrayLE(<Uint8Array>array);
    } else {
      throw new TypeError("Unsupported generic type");
    }
  }

  @inline
  static fromBytesLE(array: u8[]): i128 {
    return i128.fromUint8ArrayLE(changetype<Uint8Array>(array));
  }

  @inline
  static fromBytesBE(array: u8[]): i128 {
    return i128.fromUint8ArrayBE(changetype<Uint8Array>(array));
  }

  @inline
  static fromUint8ArrayLE(array: Uint8Array): i128 {
    assert(array.length && (array.length & 15) == 0);
    var buffer = array.dataStart;
    return new i128(
      load<u64>(buffer, 0 * sizeof<u64>()),
      load<u64>(buffer, 1 * sizeof<u64>())
    );
  }

  static fromUint8ArrayBE(array: Uint8Array): i128 {
    assert(array.length && (array.length & 15) == 0);
    var buffer = array.dataStart;
    return new i128(
      bswap<u64>(load<u64>(buffer, 1 * sizeof<u64>())),
      bswap<u64>(load<u64>(buffer, 0 * sizeof<u64>()))
    );
  }

  /**
   * Create 128-bit signed integer from generic type T
   * @param  value
   * @return 128-bit signed integer
   */
  @inline
  static from<T>(value: T): i128 {
         if (value instanceof bool) { return i128.fromU64(<u64>value); }
    else if (value instanceof i8)   { return i128.fromI64(<i64>value); }
    else if (value instanceof u8)   { return i128.fromU64(<u64>value); }
    else if (value instanceof i16)  { return i128.fromI64(<i64>value); }
    else if (value instanceof u16)  { return i128.fromU64(<u64>value); }
    else if (value instanceof i32)  { return i128.fromI64(<i64>value); }
    else if (value instanceof u32)  { return i128.fromU64(<u64>value); }
    else if (value instanceof i64)  { return i128.fromI64(<i64>value); }
    else if (value instanceof u64)  { return i128.fromU64(<u64>value); }
    else if (value instanceof f32)  { return i128.fromF64(<f64>value); }
    else if (value instanceof f64)  { return i128.fromF64(<f64>value); }
    else if (value instanceof i128) { return i128.fromI128(<i128>value); }
    else if (value instanceof u128) { return i128.fromU128(<u128>value); }
    else if (value instanceof i256) { return i128.fromI256(<i256>value); }
    else if (value instanceof u256) { return i128.fromU256(<u256>value); }
    else if (value instanceof u8[]) { return i128.fromBytes(<u8[]>value); }
    else { throw new TypeError("Unsupported generic type"); }
  }

  constructor(
    public lo: u64 = 0,
    public hi: i64 = 0,
  ) {}

  @inline
  isPos(): bool {
    return this.hi >= 0;
  }

  @inline
  isNeg(): bool {
    return this.hi < 0;
  }

  @inline
  isZero(): bool {
    return !(this.lo | this.hi);
  }

  @inline @operator.prefix('~')
  not(): i128 {
    return new i128(~this.lo, ~this.hi);
  }

  @inline @operator.prefix('+')
  pos(): i128 {
    return this;
  }

  @inline @operator.prefix('-')
  neg(): i128 {
    var lo = ~this.lo;
    var hi = ~this.hi;
    var lo1 = lo + 1;
    return new i128(lo1, hi + i64(lo1 < 0));
  }

  @inline @operator.prefix('!')
  static isEmpty(value: i128): bool {
    return value.isZero();
  }

  @inline @operator('|')
  static or(a: i128, b: i128): i128 {
    return new i128(a.lo | b.lo, a.hi | b.hi);
  }

  @inline @operator('^')
  static xor(a: i128, b: u128): i128 {
    return new i128(a.lo ^ b.lo, a.hi ^ b.hi);
  }

  @inline @operator('&')
  static and(a: i128, b: i128): i128 {
    return new i128(a.lo & b.lo, a.hi & b.hi);
  }

  @inline @operator('<<')
  static shl(value: i128, shift: i32): i128 {
    shift &= 127;

    // need for preventing redundant i32 -> u64 extends
    var shift64: i64 = shift;

    var mod1: i64 = ((((shift64 + 127) | shift64) & 64) >>> 6) - 1;
    var mod2: i64 = (shift64 >>> 6) - 1;

    shift64 &= 63;

    var vl = value.lo;
    var lo = vl << shift64;
    var hi = lo & ~mod2;

    hi |= ((value.hi << shift64) | ((vl >>> (64 - shift64)) & mod1)) & mod2;

    return new i128(lo & mod2, hi);
  }

  @inline @operator('>>>')
  static shr_u(value: i128, shift: i32): i128 {
    shift &= 127;

    // need for preventing redundant i32 -> u64 extends
    var shift64: i64 = shift;

    var mod1: i64 = ((((shift64 + 127) | shift64) & 64) >>> 6) - 1;
    var mod2: i64 = (shift64 >>> 6) - 1;

    shift64 &= 63;

    var vh = value.hi;
    var hi = vh >>> shift64;
    var lo = hi & ~mod2;

    lo |= ((value.lo >>> shift64) | ((vh << (64 - shift64)) & mod1)) & mod2;

    return new i128(lo, hi & mod2);
  }

  @inline @operator('+')
  static add(a: i128, b: i128): i128 {
    var blo = b.lo;
    var bhi = b.hi;
    var lo = a.lo + blo - (bhi >>> 63);
    var hi = a.hi + bhi + i64(lo < blo);
    return new i128(lo, hi);
  }

  @inline @operator('-')
  static sub(a: i128, b: i128): i128 {
    var alo = a.lo;
    var bhi = b.hi;
    var lo = alo  - b.lo + (bhi >>> 63);
    var hi = a.hi - bhi  - i64(lo > alo);
    return new i128(lo, hi);
  }

  @inline @operator('==')
  static eq(a: i128, b: i128): bool {
    return a.hi == b.hi && a.lo == b.lo;
  }

  @inline @operator('!=')
  static ne(a: i128, b: i128): bool {
    return !i128.eq(a, b);
  }

  @inline @operator('<')
  static lt(a: i128, b: i128): bool {
    var ah = a.hi, bh = b.hi;
    return ah == bh ? a.lo < b.lo : ah < bh;
  }

  @inline @operator('>')
  static gt(a: i128, b: i128): bool {
    var ah = a.hi, bh = b.hi;
    return ah == bh ? a.lo > b.lo : ah > bh;
  }

  @inline @operator('<=')
  static le(a: i128, b: i128): bool {
    return !i128.gt(a, b);
  }

  @inline @operator('>=')
  static ge(a: i128, b: i128): bool {
    return !i128.lt(a, b);
  }

  @inline
  static ord(a: i128, b: i128): i32 {
    var dlo = a.lo - b.lo;
    var dhi = a.hi - b.hi;
    var cmp = <i32>select<i64>(dhi, dlo, dhi != 0);
    // normalize to [-1, 0, 1]
    return i32(cmp > 0) - i32(cmp < 0);
  }

  @inline
  static popcnt(value: i128): i32 {
    return <i32>(popcnt(value.lo) + popcnt(value.hi));
  }

  @inline
  static clz(value: i128): i32 {
    return __clz128(value.lo, value.hi);
  }

  @inline
  static ctz(value: i128): i32 {
    return __ctz128(value.lo, value.hi);
  }

  @inline
  static abs(value: i128): i128 {
    var lo = value.lo;
    var hi = value.hi;
    if (hi >>> 63) {
      lo = -lo;
      hi = ~hi + i64(lo == 0);
    }
    return new i128(lo, hi);
  }

  @inline
  private toArrayBufferLE(buffer: usize): void {
    store<u64>(buffer, this.lo, 0 * sizeof<u64>());
    store<u64>(buffer, this.hi, 1 * sizeof<u64>());
  }

  @inline
  private toArrayBufferBE(buffer: usize): void {
    store<u64>(buffer, bswap<u64>(this.hi), 0 * sizeof<u64>());
    store<u64>(buffer, bswap<u64>(this.lo), 1 * sizeof<u64>());
  }

  @inline
  private toArrayBuffer(buffer: usize, bigEndian: bool = false): void {
    if (bigEndian) {
      this.toArrayBufferBE(buffer);
    } else {
      this.toArrayBufferLE(buffer);
    }
  }

  /**
   * Convert to byte array
   * @param bigEndian Little or Big Endian? Default: false
   * @returns  Array of bytes
   */
   @inline
   toBytes(bigEndian: bool = false): u8[] {
     var result = new Array<u8>(16);
     this.toArrayBuffer(result.dataStart, bigEndian);
     return result;
   }


  /**
   * Convert to byte static array
   * @param bigEndian Little or Big Endian? Default: false
   * @returns  StaticArray of bytes
   */
    @inline
    toStaticBytes(bigEndian: bool = false): StaticArray<u8> {
      var result = new StaticArray<u8>(16);
      this.toArrayBuffer(changetype<usize>(result), bigEndian);
      return result;
    }

   /**
    * Convert to Uint8Array
    * @param bigEndian Little or Big Endian? Default: false
    * @returns  Uint8Array
    */
   @inline
   toUint8Array(bigEndian: bool = false): Uint8Array {
     var result = new Uint8Array(16);
     this.toArrayBuffer(result.dataStart, bigEndian);
     return result;
   }

  // TODO
}

export class i128Safe extends i128 {
    // TODO
}

// export namespace safe {
export class i256Safe extends i256 {
    // TODO
}

export class u256Safe extends u256 {
    // TODO override add, sub, inc, dec, mul, div, rem operators
}


// @external("safe_u128.spec.as", "logStr")
// declare function logStr(str: string): void;

// @external("safe_u128.spec.as", "logF64")
// declare function logF64(v: f64): void;

// export namespace safe {
export class u128Safe extends u128 {

  @inline static get Zero(): u128Safe { return new u128Safe(); }
  @inline static get One():  u128Safe { return new u128Safe(1); }
  @inline static get Min():  u128Safe { return new u128Safe(); }
  @inline static get Max():  u128Safe { return new u128Safe(-1, -1); }

  @inline
  static fromString(value: string, radix: i32 = 10): u128Safe {
    return changetype<u128Safe>(atou128(value, radix));
  }

  @inline
  static fromI256(value: i256): u128Safe {
    return changetype<u128Safe>(u128.fromI256(value));
  }

  @inline
  static fromI256Safe(value: i256Safe): u128Safe {
    return changetype<u128Safe>(u128.fromI256(value));
  }

  @inline
  static fromU256(value: u256Safe): u128Safe {
    return changetype<u128Safe>(u128.fromU256(value));
  }

  @inline
  static fromI128(value: i128): u128Safe {
    return changetype<u128Safe>(u128.fromI128(value));
  }

  @inline
  static fromI128Safe(value: i128Safe): u128Safe {
    return changetype<u128Safe>(u128.fromI128(value));
  }

  @inline
  static fromU128(value: u128Safe): u128Safe {
    return changetype<u128Safe>(u128.fromU128(value));
  }

  @inline
  static fromI64(value: i64): u128Safe {
    return changetype<u128Safe>(u128.fromI64(value));
  }

  @inline
  static fromU64(value: u64): u128Safe {
    return changetype<u128Safe>(u128.fromU64(value));
  }

  @inline
  static fromF64(value: f64): u128Safe {
    return changetype<u128Safe>(u128.fromF64(value));
  }

  @inline
  static fromF32(value: f32): u128Safe {
    return changetype<u128Safe>(u128.fromF32(value));
  }

  @inline
  static fromI32(value: i32): u128Safe {
    return changetype<u128Safe>(u128.fromI32(value));
  }

  @inline
  static fromU32(value: u32): u128Safe {
    return changetype<u128Safe>(u128.fromU32(value));
  }

  @inline
  static fromBool(value: bool): u128Safe {
    return changetype<u128Safe>(u128.fromBool(value));
  }

  @inline
  static fromBits(lo1: u32, lo2: u32, hi1: u32, hi2: u32): u128Safe {
    return changetype<u128Safe>(u128.fromBits(lo1, lo2, hi1, hi2));
  }

  @inline
  static fromBytes<T>(array: T, bigEndian: bool = false): u128Safe {
    return changetype<u128Safe>(u128.fromBytes<T>(array, bigEndian));
  }

  @inline
  static fromBytesLE(array: u8[]): u128Safe {
    return changetype<u128Safe>(u128.fromBytesLE(array));
  }

  @inline
  static fromBytesBE(array: u8[]): u128Safe {
    return changetype<u128Safe>(u128.fromBytesBE(array));
  }

  @inline
  static fromUint8ArrayLE(array: Uint8Array): u128Safe {
    return changetype<u128Safe>(u128.fromUint8ArrayLE(array));
  }

  @inline
  static fromUint8ArrayBE(array: Uint8Array): u128Safe {
    return changetype<u128Safe>(u128.fromUint8ArrayBE(array));
  }

  /**
   * Create 128-bit unsigned integer from generic type T
   * @param  value
   * @returns 128-bit unsigned integer
   */
  @inline
  static from<T>(value: T): u128Safe {
         if (value instanceof bool)       return u128Safe.fromU64(<u64>value);
    else if (value instanceof i8)         return u128Safe.fromI64(<i64>value);
    else if (value instanceof u8)         return u128Safe.fromU64(<u64>value);
    else if (value instanceof i16)        return u128Safe.fromI64(<i64>value);
    else if (value instanceof u16)        return u128Safe.fromU64(<u64>value);
    else if (value instanceof i32)        return u128Safe.fromI64(<i64>value);
    else if (value instanceof u32)        return u128Safe.fromU64(<u64>value);
    else if (value instanceof i64)        return u128Safe.fromI64(<i64>value);
    else if (value instanceof u64)        return u128Safe.fromU64(<u64>value);
    else if (value instanceof f32)        return u128Safe.fromF64(<f64>value);
    else if (value instanceof f64)        return u128Safe.fromF64(<f64>value);
    else if (value instanceof i128)       return u128Safe.fromI128(<i128>value);
    else if (value instanceof i128Safe)   return u128Safe.fromI128(<i128Safe>value);
    else if (value instanceof u128Safe)       return u128Safe.fromU128(<u128Safe>value);
    else if (value instanceof u128)       return u128Safe.fromU128(<u128>value);
    else if (value instanceof i256)       return u128Safe.fromI128(<i256>value);
    else if (value instanceof i256Safe)   return u128Safe.fromI256(<i256Safe>value);
    else if (value instanceof u256Safe)       return u128Safe.fromU256(<u256Safe>value);
    else if (value instanceof u8[])       return u128Safe.fromBytes(<u8[]>value);
    else if (value instanceof Uint8Array) return u128Safe.fromBytes(<Uint8Array>value);
    else if (value instanceof String)     return u128Safe.fromString(<string>value);
    else throw new TypeError("Unsupported generic type");
  }

  @inline @operator('|')
  static or(a: u128Safe, b: u128Safe): u128Safe {
    return changetype<u128Safe>(u128.or(a, b));
  }

  @inline @operator('^')
  static xor(a: u128Safe, b: u128Safe): u128Safe {
    return changetype<u128Safe>(u128.xor(a, b));
  }

  @inline @operator('&')
  static and(a: u128Safe, b: u128Safe): u128Safe {
    return changetype<u128Safe>(u128.and(a, b));
  }

  @inline @operator('<<')
  static shl(value: u128Safe, shift: i32): u128Safe {
    return changetype<u128Safe>(u128.shl(value, shift));
  }

  @inline @operator('>>')
  static shr(value: u128Safe, shift: i32): u128Safe {
   return changetype<u128Safe>(u128.shr(value, shift));
  }

  @inline @operator('>>>')
  static shr_u(value: u128Safe, shift: i32): u128Safe {
    return u128Safe.shr(value, shift);
  }

  @inline
  static rotl(value: u128Safe, shift: i32): u128Safe {
    return changetype<u128Safe>(u128.rotl(value, shift));
  }

  @inline
  static rotr(value: u128Safe, shift: i32): u128Safe {
    return changetype<u128Safe>(u128.rotr(value, shift));
  }

  @operator.prefix('++')
  preInc(): this {
    if ((this.lo & this.hi) == <u64>-1) { // if this == max
      throw new RangeError('Overflow during prefix incrementing');
    }
    super.preInc();
    return this;
  }

  @operator.prefix('--')
  preDec(): this {
    if ((this.lo | this.hi) == 0) { // if this == 0
      throw new RangeError('Underflow during prefix decrementing');
    }
    super.preDec();
    return this;
  }

  @inline @operator.postfix('++')
  postInc(): u128Safe {
    return this.clone().preInc();
  }

  @inline @operator.postfix('--')
  postDec(): u128Safe {
    return this.clone().preDec();
  }

  @operator('+')
  static add(a: u128Safe, b: u128Safe): u128Safe {
    var bl = b.lo;
    var lo = a.lo + bl;
    var c  = u64(lo < bl);
    var x  = a.hi;
    var y  = b.hi;
    var hi = x + y + c;
    if (((hi ^ x) & (hi ^ y)) < c) {
      throw new RangeError('Overflow during addision');
    }
    return new u128Safe(lo, hi);
  }

  @operator('-')
  static sub(a: u128Safe, b: u128Safe): u128Safe {
    if (a < b) throw new RangeError("Underflow during substraction");
    return changetype<u128Safe>(
        u128.sub(changetype<u128>(a), changetype<u128>(b))
    );
  }

  @operator('*')
  static mul(a: u128Safe, b: u128Safe): u128Safe {
    if (a.isZero() || b.isZero()) {
      return u128Safe.Zero;
    }
    var s = u128Safe.clz(a) + u128Safe.clz(b);
    if (s < 127) { // defenitely overflow
      throw new RangeError("Overflow during multiplication");
    }
    if (s == 127) { // this may overflow or not. Need extra checks.
      // See Hacker's Delight, 2nd Edition. 213 Overflow Detection
      // @ts-ignore
      let tmp = u128.mul(changetype<u128>(a), changetype<u128>(b) >> 1);
      // @ts-ignore
      if (tmp.hi >>> 63) { // (signed)t < 0
        throw new RangeError("Overflow during multiplication");
      }
      // @ts-ignore
      let z = tmp << 1;
      if (b.lo & 1) {
        // @ts-ignore
        z += a;
        // @ts-ignore
        if (z < a) {
          throw new RangeError("Overflow during multiplication");
        }
      }
      return changetype<u128Safe>(z);
    }
    return changetype<u128Safe>(
        u128.mul(changetype<u128>(a), changetype<u128>(b))
    );
  }

  @inline @operator('/')
  static div(a: u128Safe, b: u128Safe): u128Safe {
    return changetype<u128Safe>(u128.div(a, b));
  }

  @inline @operator('**')
  static pow(base: u128Safe, exponent: i32): u128Safe {
    if (isPowerOverflow128(base, exponent)) {
      throw new Error("Overflow during exponentiation");
    }
    return changetype<u128Safe>(u128.pow(changetype<u128>(base), exponent));
  }

  @inline @operator('%')
  static rem(a: u128Safe, b: u128Safe): u128Safe {
    return changetype<u128Safe>(u128.rem(a, b));
  }

  @inline
  static div10(value: u128Safe): u128Safe {
    return changetype<u128Safe>(u128.div10(value));
  }

  @inline
  static rem10(value: u128Safe): u128Safe {
    return changetype<u128Safe>(u128.rem10(value));
  }

  // compute floor(sqrt(x))
  @inline
  static sqrt(value: u128Safe): u128Safe {
    return changetype<u128Safe>(u128.sqrt(value));
  }

  @inline
  static muldiv(number: u128Safe, numerator: u128Safe, denominator: u128Safe): u128Safe {
    // TODO: Need implement overflow checking
    return changetype<u128Safe>(u128.muldiv(number, numerator, denominator));
  }

  @inline
  toUnchecked(): u128 {
    return changetype<u128>(this);
  }

  @inline
  as<T>(): T {
    var dummy: T;

         if (dummy instanceof bool)       return <T>this.toBool();
    else if (dummy instanceof i8)         return <T>this.toI64();
    else if (dummy instanceof u8)         return <T>this.toU64();
    else if (dummy instanceof i16)        return <T>this.toI64();
    else if (dummy instanceof u16)        return <T>this.toU64();
    else if (dummy instanceof i32)        return <T>this.toI64();
    else if (dummy instanceof i64)        return <T>this.toI64();
    else if (dummy instanceof u32)        return <T>this.toU64();
    else if (dummy instanceof u64)        return <T>this.toU64();
    else if (dummy instanceof f32)        return <T>this.toF64();
    else if (dummy instanceof f64)        return <T>this.toF64();
    else if (dummy instanceof i128)       return <T>this.toI128();
    else if (dummy instanceof u128Safe)       return <T>this;
    else if (dummy instanceof u128)       return <T>this.toUnchecked();
    else if (dummy instanceof u256Safe)       return <T>this.toU256();
    else if (dummy instanceof u256)       return <T>this.toU256();
    else if (dummy instanceof u8[])       return <T>this.toBytes();
    else if (dummy instanceof Uint8Array) return <T>this.toUint8Array();
    else if (dummy instanceof String)     return <T>this.toString();
    else throw new TypeError('Unsupported generic type');
  }

  //
  // unsigned div and rem already contain traps
  //

  @inline
  clone(): u128Safe {
    return new u128Safe(this.lo, this.hi);
  }
}

